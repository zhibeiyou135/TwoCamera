# TwoCamera_v6detect 项目下位机通讯代码分析文档

## 概述

本项目包含两种主要的通讯方式：
1. **Modbus TCP 通讯** - 用于控制机械设备（电机、气缸等）
2. **USB 通讯** - 用于与CeleX相机进行数据传输

## 1. Modbus TCP 通讯模块

### 1.1 核心文件

#### `socket/modbussocket.h`
- **功能**: Modbus TCP通讯类的头文件定义
- **主要成员变量**:
  ```cpp
  modbus_t *ctx;              // Modbus上下文
  char* ip;                   // 服务器IP地址
  int port;                   // 端口号
  int xMaxData, xMinData, xMidData;  // X轴位置参数
  int zMAXData, zMinData;     // Z轴位置参数
  int rMaxData, rMinData;     // 旋转位置参数
  int yMAXData;               // Y轴位置参数
  ```
- **主要地址定义**:
  ```cpp
  int rotate_position_address = 41538;   // 旋转角度地址
  int rotate_flag_address = 0;           // 旋转启动信号地址
  int open_address = 24584;              // 夹爪开合地址
  int x_address = 80;                    // X轴位置地址
  int y_address = 82;                    // Y轴位置地址
  int z_address = 84;                    // Z轴位置地址
  int detect_finally_address = 1403;     // 最终检测地址
  int detect_res_address = 1404;         // 检测结果地址
  ```

#### `socket/modbussocket.cpp`
- **功能**: Modbus TCP通讯的具体实现
- **主要方法分析**:

##### 1.1.1 连接管理
```cpp
void modbusSocket::open()
```
- **逻辑**: 建立与Modbus服务器的TCP连接
- **实现**: 使用`modbus_connect(ctx)`建立连接，设置`open_flag = true`

##### 1.1.2 基础运动控制
```cpp
void modbusSocket::basic_rotate(int Rdata)
```
- **逻辑**: 基础旋转控制函数
- **实现**: 
  1. 写入目标角度到寄存器41538
  2. 计算运动时间 `sleep_time = (目标位置 - 当前位置) / 旋转速度`
  3. 启动旋转标志位
  4. 等待运动完成

```cpp
void modbusSocket::x_basic_move(int Xdata)
```
- **逻辑**: X轴基础移动控制
- **实现**: 
  1. 写入目标位置到寄存器80
  2. 计算运动时间
  3. 等待运动完成

##### 1.1.3 复合动作控制
```cpp
void modbusSocket::x_mobile()
```
- **逻辑**: X轴复合移动（最大→最小→中间位置）
- **实现**: 依次执行三个位置的移动

```cpp
void modbusSocket::rotate_x_mobile()
```
- **逻辑**: 旋转+X轴移动的复合动作
- **实现**: 先旋转到最大角度，再执行X轴移动序列

##### 1.1.4 夹爪控制
```cpp
void modbusSocket::q_open()    // 夹爪松开
void modbusSocket::q_close()   // 夹爪抓取
```
- **逻辑**: 控制夹爪的开合
- **实现**: 向地址24584写入0（松开）或1（抓取）

##### 1.1.5 自动检测模式
```cpp
void modbusSocket::run()
```
- **逻辑**: 主循环，监听检测信号并执行相应动作
- **实现**:
  1. 持续读取检测标志位（地址1503、1504）
  2. 当检测到信号时，执行预设的动作序列
  3. 自动重连机制

### 1.2 控制逻辑总结

#### 运动参数配置
- **X轴**: 最大33700，最小13000，中间24000
- **Z轴**: 最大15000，最小0
- **旋转**: 最大42000，最小0
- **Y轴**: 最大29200
- **旋转速度**: 2500
- **X轴速度**: 5500

#### 自动检测流程
1. 监听检测信号（地址1503、1504）
2. 收到信号后执行动作序列
3. 可选择录制数据
4. 完成后等待下一个检测信号

## 2. USB 通讯模块（CeleX相机）

### 2.1 核心文件架构

#### `CeleX/cx3driver/usbinterface.h/cpp`
- **功能**: USB接口底层驱动
- **主要功能**:
  - USB设备枚举和连接
  - 批量传输和中断传输
  - 视频流和IMU数据接收

#### `CeleX/cx3driver/cypress.h/cpp`
- **功能**: Cypress USB控制器接口
- **主要功能**:
  - USB控制传输
  - 设备信息读取（序列号、固件版本）
  - 视频流控制

#### `CeleX/cx3driver/celedriver.h/cpp`
- **功能**: CeleX相机驱动封装
- **主要功能**:
  - I2C寄存器读写
  - MIPI寄存器读写
  - 传感器数据获取

### 2.2 USB通讯详细分析

#### 2.2.1 设备识别
```cpp
#define CYPRESS_DEVICE_VENDOR_ID    0x04b4
#define CYPRESS_DEVICE_PRODUCT_ID   0x00f1
```
- **逻辑**: 通过VID/PID识别CeleX相机设备

#### 2.2.2 USB传输类型
1. **控制传输**: 用于寄存器读写和设备控制
2. **批量传输**: 用于视频数据传输
3. **中断传输**: 用于IMU数据传输

#### 2.2.3 数据流管理
```cpp
bool USBInterface::videoStart(void)
```
- **逻辑**: 启动视频数据传输线程
- **实现**: 创建工作线程，处理USB传输事件

```cpp
void USBInterface::worker(void)
```
- **逻辑**: USB传输工作线程
- **实现**: 
  1. 监听传输错误
  2. 自动重连机制
  3. 处理libusb事件

#### 2.2.4 相机控制接口
```cpp
bool CeleDriver::i2cSet(uint16_t reg, uint16_t value)
bool CeleDriver::i2cGet(uint16_t reg, uint16_t &value)
```
- **逻辑**: 通过I2C接口控制相机寄存器
- **实现**: 封装USB控制传输

### 2.3 相机数据处理流程

#### 数据获取
```cpp
void CeleX5::getCeleXRawData(uint8_t *pData, uint32_t &length)
```
- **逻辑**: 获取原始相机数据
- **实现**: 从USB缓冲区读取MIPI格式数据

#### 数据处理
- **事件流处理**: 将原始数据转换为事件流
- **图像重建**: 根据事件流重建图像
- **IMU数据**: 处理惯性测量单元数据

## 3. 系统集成架构

### 3.1 主窗口集成（mainwindow.cpp）

#### 通讯模块初始化
```cpp
#include "socket/modbussocket.h"  // Modbus通讯（当前被注释）
```
- **注意**: 当前版本中Modbus通讯功能被注释，未实际使用

#### 相机通讯集成
```cpp
auto dvsDataSource = DVSDataSource::getInstance();
auto dvCapture = CameraCapture::getInstance();
```
- **逻辑**: 通过单例模式管理相机实例
- **实现**: 相机启动、数据接收、图像处理

### 3.2 控制按钮映射

#### UI按钮定义
```cpp
auto connectButton = new QPushButton(tr("自动检测模式"));
auto q_openButton = new QPushButton(tr("松开"));
auto q_closeButton = new QPushButton(tr("抓取"));
auto rotateButton = new QPushButton(tr("旋转"));
auto reventButton = new QPushButton(tr("x轴旋转"));
auto x_mobile = new QPushButton(tr("X轴移动"));
auto rotate_45 = new QPushButton(tr("旋转45度"));
auto reset = new QPushButton(tr("复位"));
auto begin = new QPushButton(tr("开始"));
auto stop_emergency = new QPushButton(tr("即停紧急"));
```

#### 按钮功能映射
| 按钮名称 | 对应功能 | Modbus方法 |
|---------|---------|-----------|
| 自动检测模式 | 启动自动检测 | `run()` |
| 松开 | 夹爪松开 | `q_open()` |
| 抓取 | 夹爪抓取 | `q_close()` |
| 旋转 | 旋转到最大角度 | `rotate()` |
| x轴旋转 | X轴旋转复合动作 | `revent()` |
| X轴移动 | X轴移动序列 | `x_mobile()` |
| 旋转45度 | 45度步进旋转 | `click_rotate_x_45()` |
| 复位 | 系统复位 | `reset()` |
| 开始 | 启动系统 | `begin()` |
| 即停紧急 | 紧急停止 | `stop_emergency()` |

## 4. 通讯协议总结

### 4.1 Modbus TCP协议
- **传输层**: TCP/IP
- **应用层**: Modbus协议
- **数据格式**: 
  - 寄存器读写：16位数据
  - 线圈读写：1位布尔数据
- **地址空间**: 0-65535

### 4.2 USB协议
- **物理层**: USB 2.0/3.0
- **传输类型**: 控制传输、批量传输、中断传输
- **数据格式**: 
  - 视频数据：MIPI格式
  - IMU数据：自定义格式
  - 控制数据：寄存器格式

## 5. 错误处理和容错机制

### 5.1 Modbus通讯容错
- **自动重连**: 检测到连接断开时自动重连
- **超时处理**: 设置合理的超时时间
- **错误日志**: 详细的错误信息输出

### 5.2 USB通讯容错
- **传输错误处理**: 检测各种USB传输错误
- **设备重新枚举**: 设备断开后自动重新连接
- **缓冲区管理**: 防止数据溢出

## 6. 性能优化

### 6.1 多线程处理
- **Modbus**: 独立线程处理通讯
- **USB**: 专用工作线程处理数据传输
- **UI**: 主线程处理用户界面

### 6.2 内存管理
- **缓冲区复用**: 减少内存分配开销
- **智能指针**: 自动内存管理
- **数据拷贝优化**: 减少不必要的数据拷贝

## 7. 配置和部署

### 7.1 Modbus配置
- **IP地址**: 可配置的服务器地址
- **端口**: 默认Modbus TCP端口
- **运动参数**: 可调整的位置和速度参数

### 7.2 USB配置
- **设备识别**: VID/PID配置
- **传输参数**: 缓冲区大小、超时时间
- **相机参数**: 分辨率、帧率等

## 8. 维护和调试

### 8.1 日志系统
- **详细日志**: 记录所有通讯活动
- **错误追踪**: 详细的错误信息
- **性能监控**: 传输速率和延迟监控

### 8.2 调试工具
- **Modbus调试**: 寄存器读写测试
- **USB调试**: 设备枚举和传输测试
- **集成测试**: 完整的系统功能测试

## 结论

本项目的下位机通讯系统采用了模块化设计，通过Modbus TCP协议控制机械设备，通过USB协议与相机进行高速数据传输。系统具有良好的容错性和可扩展性，能够满足工业自动化检测的需求。

主要特点：
1. **双通道通讯**: Modbus控制 + USB数据传输
2. **自动化程度高**: 支持自动检测和响应
3. **实时性强**: 多线程并发处理
4. **稳定性好**: 完善的错误处理和重连机制
5. **可维护性强**: 清晰的模块划分和接口设计 